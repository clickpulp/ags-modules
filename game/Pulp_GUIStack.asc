// TERMS OF USE - CLICKPULP AGS MODULES (clickpulp-ags-modules)
//
// MIT License
//
// Copyright (c) 2024 Clickpulp, LLC
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#region Definitions

#define STACK_SIZE 8
#define GUI_ZORDER_START 900

struct _GUIStackItem {
  int guiID;
  int guiControlFocusID;
  bool withOverlay;
  GUI* TheGUI;
  
  import void OpenGUI(int zOrder, bool skipControlFocus=false);
  import void CloseGUI();
  import void Clear();
};

#endregion

#region Variables

_GUIStackItem _guiStack[STACK_SIZE];
int _stackIndex = -1;
bool _poppingAllGUIs;

#endregion

#region Private

int _get_stack_zorder() {
  return GUI_ZORDER_START * (_stackIndex + 2);
}

void _show_overlay(int zOrder) {
  if (pulpGlobals.OverlayGUI == null) return;
  
  pulpGlobals.OverlayGUI.ZOrder = zOrder;  
  
  if (!pulpGlobals.OverlayGUI.Visible) {
    pulpGlobals.OverlayGUI.Visible = true;
  }
}

void _hide_overlay() {
  if (pulpGlobals.OverlayGUI == null || !pulpGlobals.OverlayGUI.Visible) return;
  
  pulpGlobals.OverlayGUI.Visible = false;
}

#ifdef __ARROWSELECT_MODULE__
void _set_arrowselect_room_filters(bool enabled) {
  ArrowSelect.filterInteractiveType(eInteractiveTypeObject, enabled);
  ArrowSelect.filterInteractiveType(eInteractiveTypeCharacter, enabled);
  ArrowSelect.filterInteractiveType(eInteractiveTypeHotspot, enabled);
}
#endif

bool _is_controller_connected() {
#ifdef __INPUT_MODULE__
  return (Input.ControllerConnected || game.debug_mode);
#else
  return false;
#endif
}

#endregion // Private


#region _GUIStackItem

void _GUIStackItem::Clear() {
  this.guiID = -1;
  this.TheGUI = null;
  this.withOverlay = false;
  this.guiControlFocusID = -1;
}

void _GUIStackItem::OpenGUI(int zOrder, bool skipControlFocus) {    
  if (this.withOverlay) _show_overlay(zOrder - 1);
 
  this.TheGUI.ZOrder = zOrder;
  this.TheGUI.Visible = true;
  
#ifdef TwoClickHandler  
  TwoClickHandler.Close();
#endif
  
  if (_is_controller_connected() && !skipControlFocus && this.guiControlFocusID >= 0) {
    Mouse.PushHistory();
    Mouse.PlaceOnControl(this.TheGUI.Controls[this.guiControlFocusID]);
  }
  
  if (Mouse.Mode != eModeUseinv || pulpGlobals.InventoryGUI != null && this.TheGUI != pulpGlobals.InventoryGUI) {
    Mouse.UseModeGraphic(eModePointer);
  }
  
#ifdef __ARROWSELECT_MODULE__
  if (_stackIndex == 0) {
    _set_arrowselect_room_filters(false);
  }
#endif
}

void _GUIStackItem::CloseGUI() {
  GUI* g = gui[this.guiID];
  g.Visible = false;
  
  if (Mouse.Mode != eModeUseinv) Mouse.UseDefaultGraphic();
  
  if (_stackIndex > 0) {
    if (!_guiStack[_stackIndex - 1].withOverlay) _hide_overlay();
    if (_guiStack[_stackIndex - 1].guiControlFocusID >= 0 && _is_controller_connected()) {
      Mouse.PopHistory();
    }
  }
  else if (_stackIndex == 0) {
    _hide_overlay();
    if (_guiStack[0].guiControlFocusID >= 0 && (Input.ControllerConnected || game.debug_mode)) {
      Mouse.PopHistory();
    }
    _set_arrowselect_room_filters(true);
  }
}

#endregion

#region _GUIStackItem

int get_GUICount(static GUIStack) {
  return _stackIndex + 1;
}

bool get_ShowingGUI(static GUIStack) {
  return GUIStack.GUICount > 0;
}

GUI* get_TopGUI(static GUIStack) {
  if (_stackIndex < 0) return null;
  return gui[_guiStack[_stackIndex].guiID];
}

static void GUIStack::PushGUI(GUI* g, GUIControl* controlToFocus, bool closePreviousGUI, bool withOverlay) { 
  if (g == null) {
    System.Log(eLogWarn, "[GUIStack] Tried to push null GUI");
    return;
  }
  
  if (_stackIndex >= 0) {
    if (_guiStack[_stackIndex].guiID == g.ID) {
      System.Log(eLogWarn, "[GUIStack] Tried to push the same gui %s (%d) into stack. Will not push", g.ScriptName, g.ID);  
      return;
    }
  
    if (closePreviousGUI) {
      _guiStack[_stackIndex].CloseGUI();
    }
  }
  
  if (_stackIndex + 1 == STACK_SIZE) {
    String message = String.Format("[GUIStack] Tried to push gui %s (%d) into full stack. Will not push", g.ScriptName, g.ID);
    System.Log(eLogError, message);
#ifdef DEBUG
    AbortGame(message);
#endif
    return;
  }
  
  _stackIndex++;
  _guiStack[_stackIndex].guiID = g.ID;
  _guiStack[_stackIndex].TheGUI = gui[g.ID];
  _guiStack[_stackIndex].withOverlay = withOverlay;
  if (controlToFocus != null) {
    _guiStack[_stackIndex].guiControlFocusID = controlToFocus.ID;
  }
  
  _guiStack[_stackIndex].OpenGUI(_get_stack_zorder());
  
  System.Log(eLogDebug, "[GUIStack] Push: %s", _guiStack[_stackIndex].TheGUI.ScriptName);
  Signal.Dispatch("gui_pushed", _guiStack[_stackIndex].guiID);
}

static void GUIStack::PopGUI() {
  if (_stackIndex < 0) {
    System.Log(eLogWarn, "[GUIStack] Tried to pop GUI when the stack is empty");
    return;
  }
  
  _guiStack[_stackIndex].CloseGUI();
  
  System.Log(eLogDebug, "[GUIStack] Pop: %s", _guiStack[_stackIndex].TheGUI.ScriptName);
  Signal.Dispatch("gui_popped", _guiStack[_stackIndex].guiID);
  
  _guiStack[_stackIndex].Clear();
  _stackIndex--;
  
  if (!_poppingAllGUIs && _stackIndex >= 0) {
    _guiStack[_stackIndex].OpenGUI(_get_stack_zorder(), true);
    Signal.Dispatch("gui_pushed", _guiStack[_stackIndex].guiID);
  }
}

static void GUIStack::PopAllGUIs(GUI* untilGUI) {
  if (_stackIndex < 0) {
    System.Log(eLogWarn, "[GUIStack] Tried to pop all GUIs when the stack is empty");
    return;
  }
  
  _poppingAllGUIs = true;
  bool targetGUIPopped = false;
  
  while (!targetGUIPopped && GUIStack.GUICount > 0) {
    targetGUIPopped = untilGUI != null && GUIStack.TopGUI == untilGUI;
    GUIStack.PopGUI();
  }
  
  _poppingAllGUIs = false;
  
  if (targetGUIPopped && GUIStack.GUICount > 0) {
    _guiStack[_stackIndex].OpenGUI(_get_stack_zorder(), true);
  }
  
  if (GUIStack.GUICount == 0) Signal.Dispatch("guis_popped");
}

static int GUIStack::GetGUIIndex(GUI* g) {
  if (g != null) {
    for (int i = 0; i <= _stackIndex; i++) {
      if (_guiStack[i].guiID == g.ID) return i;
    }
  }
  
  return -1;
}

static bool GUIStack::IsGUIInStack(GUI* g) {
  return GUIStack.GetGUIIndex(g) >= 0;
}

#endregion
